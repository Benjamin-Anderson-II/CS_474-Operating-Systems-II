diff --git a/Makefile b/Makefile
index a5ab617..1e46c1a 100644
--- a/Makefile
+++ b/Makefile
@@ -188,6 +188,8 @@ UPROGS=\
 	$U/_grind\
 	$U/_wc\
 	$U/_zombie\
+	$U/_trace\
+	$U/_sysinfotest\
 
 
 
diff --git a/answers-pgtbl.txt b/answers-pgtbl.txt
new file mode 100644
index 0000000..f00b089
--- /dev/null
+++ b/answers-pgtbl.txt
@@ -0,0 +1,16 @@
+1. Which other xc6 system call(s) could be made faster using this shared page? Explain how.
+
+System calls which only pull data (and don't take arguments) could all be made faster by using this page. Examples would be calls like uptime() and sysinfo().
+
+uptime():
+    When the clockintr triggers, the current uptime could be copied into the page which would then be read just like getpid().
+sysinfo():
+    If cpu load averages are taken into account, then they would be added in at the same time as uptime, though I'm unsure of the exact process. The number of processes and the available memory are easier, however. When they change due to a fork or some kind of memory alloc/free, the data in the page would simply update while the function is being carried out.
+
+
+
+2. Explain the output of `vmprint()` in terms of Fig 3.4 from the xv6 book. What does page 0 contain? What is in page 2? When running in user mode, could the process read/write the memory mapped by page 1? What does the third to last page contain?
+
+- Page 0 contains the trampoline and page 2 contains the syscall page that we created.
+- No, the user could not read/write memory mapped by page 1, as page 1 is the trapframe and does not have PTE_U set.
+- Unless I'm reading exec.c incorrectly, the third to last page is the user's "program segment" as loadseg() puts it. Following it are two more pages, with the latter being the user program stack.
diff --git a/kernel/defs.h b/kernel/defs.h
index 3564db4..ff9b05e 100644
--- a/kernel/defs.h
+++ b/kernel/defs.h
@@ -63,6 +63,7 @@ void            ramdiskrw(struct buf*);
 void*           kalloc(void);
 void            kfree(void *);
 void            kinit(void);
+uint64          kmemfree(void);
 
 // log.c
 void            initlog(int, struct superblock*);
@@ -104,6 +105,10 @@ void            yield(void);
 int             either_copyout(int user_dst, uint64 dst, void *src, uint64 len);
 int             either_copyin(void *dst, int user_src, uint64 src, uint64 len);
 void            procdump(void);
+int             trace(int);
+int             sysinfo(uint64);
+uint64          numproc(void);
+int             pgaccess(uint64, int, uint64);
 
 // swtch.S
 void            swtch(struct context*, struct context*);
@@ -166,10 +171,12 @@ int             uvmcopy(pagetable_t, pagetable_t, uint64);
 void            uvmfree(pagetable_t, uint64);
 void            uvmunmap(pagetable_t, uint64, uint64, int);
 void            uvmclear(pagetable_t, uint64);
+pte_t *         walk(pagetable_t, uint64, int);
 uint64          walkaddr(pagetable_t, uint64);
 int             copyout(pagetable_t, uint64, char *, uint64);
 int             copyin(pagetable_t, char *, uint64, uint64);
 int             copyinstr(pagetable_t, char *, uint64, uint64);
+void            vmprint(pagetable_t);
 
 // plic.c
 void            plicinit(void);
diff --git a/kernel/exec.c b/kernel/exec.c
index d62d29d..6c139cc 100644
--- a/kernel/exec.c
+++ b/kernel/exec.c
@@ -116,6 +116,8 @@ exec(char *path, char **argv)
   p->trapframe->sp = sp; // initial stack pointer
   proc_freepagetable(oldpagetable, oldsz);
 
+  if(p->pid==1) vmprint(p->pagetable);
+
   return argc; // this ends up in a0, the first argument to main(argc, argv)
 
  bad:
diff --git a/kernel/kalloc.c b/kernel/kalloc.c
index fa6a0ac..71ff816 100644
--- a/kernel/kalloc.c
+++ b/kernel/kalloc.c
@@ -80,3 +80,25 @@ kalloc(void)
     memset((char*)r, 5, PGSIZE); // fill with junk
   return (void*)r;
 }
+
+// Collect the amount of free memory in bytes
+uint64
+kmemfree(void)
+{
+  uint64 numpages = 0;
+  struct run *r;
+
+  // must hold the lock while accessing free pages
+  acquire(&kmem.lock);
+  r = kmem.freelist;
+  
+  // move through the linked list of free pages and
+  // increment the page total by PGSIZE
+  while(r != 0) {
+    numpages += PGSIZE;
+    r = r->next;
+  }
+  release(&kmem.lock);
+
+  return numpages;
+}
diff --git a/kernel/memlayout.h b/kernel/memlayout.h
index 74d2fd4..797b908 100644
--- a/kernel/memlayout.h
+++ b/kernel/memlayout.h
@@ -1,3 +1,5 @@
+#ifndef _SYS_MEMLAYOUT_H
+#define _SYS_MEMLAYOUT_H 1
 // Physical memory layout
 
 // qemu -machine virt is set up like this,
@@ -77,3 +79,5 @@ struct usyscall {
   int pid;  // Process ID
 };
 #endif
+
+#endif /* kernel/memlayout.h */
diff --git a/kernel/proc.c b/kernel/proc.c
index 22e7ce4..3aac49f 100644
--- a/kernel/proc.c
+++ b/kernel/proc.c
@@ -5,6 +5,7 @@
 #include "spinlock.h"
 #include "proc.h"
 #include "defs.h"
+#include "sysinfo.h"
 
 struct cpu cpus[NCPU];
 
@@ -127,6 +128,13 @@ found:
     return 0;
   }
 
+  // Allocate a syscall page
+  if((p->vsyscall = (struct usyscall *)kalloc()) == 0) {
+    freeproc(p);
+    release(&p->lock);
+    return 0;
+  }
+
   // An empty user page table.
   p->pagetable = proc_pagetable(p);
   if(p->pagetable == 0){
@@ -153,6 +161,9 @@ freeproc(struct proc *p)
   if(p->trapframe)
     kfree((void*)p->trapframe);
   p->trapframe = 0;
+  if(p->vsyscall)
+    kfree((void *)p->vsyscall);
+  p->vsyscall = 0;
   if(p->pagetable)
     proc_freepagetable(p->pagetable, p->sz);
   p->pagetable = 0;
@@ -164,6 +175,7 @@ freeproc(struct proc *p)
   p->killed = 0;
   p->xstate = 0;
   p->state = UNUSED;
+  p->tmsk = 0;
 }
 
 // Create a user page table for a given process,
@@ -196,6 +208,16 @@ proc_pagetable(struct proc *p)
     return 0;
   }
 
+  // map the syscall page just below TRAPFRAME
+  // It's a read-only user page table
+  if(mappages(pagetable, USYSCALL, PGSIZE, 
+              (uint64)(p->vsyscall), PTE_R | PTE_U) < 0) {
+    uvmunmap(pagetable, TRAMPOLINE, 1, 0);
+    uvmunmap(pagetable, TRAPFRAME, 1, 0);
+    uvmfree(pagetable, 0);
+    return 0;
+  }
+
   return pagetable;
 }
 
@@ -206,6 +228,7 @@ proc_freepagetable(pagetable_t pagetable, uint64 sz)
 {
   uvmunmap(pagetable, TRAMPOLINE, 1, 0);
   uvmunmap(pagetable, TRAPFRAME, 1, 0);
+  uvmunmap(pagetable, USYSCALL, 1, 0);
   uvmfree(pagetable, sz);
 }
 
@@ -239,6 +262,9 @@ userinit(void)
   p->trapframe->epc = 0;      // user program counter
   p->trapframe->sp = PGSIZE;  // user stack pointer
 
+  // place initial pid in vsyscall
+  p->vsyscall->pid = p->pid;
+
   safestrcpy(p->name, "initcode", sizeof(p->name));
   p->cwd = namei("/");
 
@@ -292,9 +318,15 @@ fork(void)
   // copy saved user registers.
   *(np->trapframe) = *(p->trapframe);
 
+  // adjust syscall page info
+  np->vsyscall->pid = np->pid;
+
   // Cause fork to return 0 in the child.
   np->trapframe->a0 = 0;
 
+  // Retain the Trace Mask
+  np->tmsk = p->tmsk;
+
   // increment reference counts on open file descriptors.
   for(i = 0; i < NOFILE; i++)
     if(p->ofile[i])
@@ -596,6 +628,35 @@ kill(int pid)
   return -1;
 }
 
+// Trace Function
+// set the trace mask to the process to be traced
+int
+trace(int n)
+{
+  struct proc *p = myproc();
+
+  if(!p)
+    return -1;
+  p->tmsk = n;
+  return 0;
+}
+
+// Sysinfo Function
+// addr is a user virtual address, pointing to a struct sysinfo
+int
+sysinfo(uint64 addr)
+{
+  struct proc *p = myproc();
+  struct sysinfo info;
+
+  info.nproc   = numproc();
+  info.freemem = kmemfree();
+  if(copyout(p->pagetable, addr, (char *)&info, sizeof(info)) < 0)
+    return -1;
+
+  return 0;
+}
+
 // Copy to either a user address, or kernel address,
 // depending on usr_dst.
 // Returns 0 on success, -1 on error.
@@ -654,3 +715,55 @@ procdump(void)
     printf("\n");
   }
 }
+
+uint64
+numproc(void)
+{
+  uint64 ret = 0;
+  struct proc *p;
+
+  for(p = proc; p < &proc[NPROC]; p++)
+    if(p->state != UNUSED)
+      ret++;
+
+  return ret;
+}
+
+// Detects and reports through bitmask which pages have 
+// been accessed. Only checks a max of 64 pages, and only
+// sets the bit if the page is: valid, user, and accessed.
+int
+pgaccess(uint64 start_va, int npages, uint64 bitmask)
+{
+  uint64 a; // address
+  pagetable_t pagetable;
+  uint64 b; // bitmask buffer
+  pte_t *pte; // page table entry
+
+  // 64bit system. Also bitmask is uint64
+  if(npages > 64)
+    return -1;
+
+  pagetable = myproc()->pagetable;
+  a = PGROUNDDOWN(start_va);
+  b = 0;
+
+  for(int i = 0; i < npages; i++, a += PGSIZE) {
+    pte = walk(pagetable, a, 0);
+    if(            pte == 0 ||
+        (*pte & PTE_V) == 0 ||
+        (*pte & PTE_U) == 0 ||
+        (*pte & PTE_A) == 0)
+      continue;
+    if(PTE2PA(*pte) >= PHYSTOP) panic("pgaccess");
+
+    b |= (1 << i); // fill the buffer
+    *pte &= ~PTE_A;
+  }
+
+  // copy out the buffer
+  if(copyout(pagetable, bitmask, (char *)&b, sizeof(b)) < 0)
+    return -1;
+
+  return 0;
+}
diff --git a/kernel/proc.h b/kernel/proc.h
index f6ca8b7..486bf8b 100644
--- a/kernel/proc.h
+++ b/kernel/proc.h
@@ -1,3 +1,7 @@
+#ifndef _SYS_PROC_H
+#define _SYS_PROC_H 1
+#include "memlayout.h"
+
 // Saved registers for kernel context switches.
 struct context {
   uint64 ra;
@@ -105,4 +109,8 @@ struct proc {
   struct file *ofile[NOFILE];  // Open files
   struct inode *cwd;           // Current directory
   char name[16];               // Process name (debugging)
+  int tmsk;                    // trace mask
+  struct usyscall *vsyscall;   // data for speeding up syscalls
 };
+
+#endif
diff --git a/kernel/riscv.h b/kernel/riscv.h
index 1691faf..04e2495 100644
--- a/kernel/riscv.h
+++ b/kernel/riscv.h
@@ -343,6 +343,7 @@ sfence_vma()
 #define PTE_W (1L << 2)
 #define PTE_X (1L << 3)
 #define PTE_U (1L << 4) // 1 -> user can access
+#define PTE_A (1L << 6) // accessed
 
 // shift a physical address to the right place for a PTE.
 #define PA2PTE(pa) ((((uint64)pa) >> 12) << 10)
@@ -362,5 +363,7 @@ sfence_vma()
 // that have the high bit set.
 #define MAXVA (1L << (9 + 9 + 9 + 12 - 1))
 
+#define PGTBL_ENTRIES 1<<9
+
 typedef uint64 pte_t;
 typedef uint64 *pagetable_t; // 512 PTEs
diff --git a/kernel/syscall.c b/kernel/syscall.c
index a857380..8f2a254 100644
--- a/kernel/syscall.c
+++ b/kernel/syscall.c
@@ -104,44 +104,114 @@ extern uint64 sys_unlink(void);
 extern uint64 sys_wait(void);
 extern uint64 sys_write(void);
 extern uint64 sys_uptime(void);
-#ifdef LAB_NET
+extern uint64 sys_trace(void);
+extern uint64 sys_sysinfo(void);
+extern uint64 sys_sigalarm(void);
+extern uint64 sys_sigreturn(void);
+extern uint64 sys_symlink(void);
+extern uint64 sys_mmap(void);
+extern uint64 sys_munmap(void);
 extern uint64 sys_connect(void);
-#endif
-#ifdef LAB_PGTBL
 extern uint64 sys_pgaccess(void);
-#endif
 
 static uint64 (*syscalls[])(void) = {
-[SYS_fork]    sys_fork,
-[SYS_exit]    sys_exit,
-[SYS_wait]    sys_wait,
-[SYS_pipe]    sys_pipe,
-[SYS_read]    sys_read,
-[SYS_kill]    sys_kill,
-[SYS_exec]    sys_exec,
-[SYS_fstat]   sys_fstat,
-[SYS_chdir]   sys_chdir,
-[SYS_dup]     sys_dup,
-[SYS_getpid]  sys_getpid,
-[SYS_sbrk]    sys_sbrk,
-[SYS_sleep]   sys_sleep,
-[SYS_uptime]  sys_uptime,
-[SYS_open]    sys_open,
-[SYS_write]   sys_write,
-[SYS_mknod]   sys_mknod,
-[SYS_unlink]  sys_unlink,
-[SYS_link]    sys_link,
-[SYS_mkdir]   sys_mkdir,
-[SYS_close]   sys_close,
-#ifdef LAB_NET
-[SYS_connect] sys_connect,
-#endif
-#ifdef LAB_PGTBL
-[SYS_pgaccess] sys_pgaccess,
-#endif
+[SYS_fork]      sys_fork,
+[SYS_exit]      sys_exit,
+[SYS_wait]      sys_wait,
+[SYS_pipe]      sys_pipe,
+[SYS_read]      sys_read,
+[SYS_kill]      sys_kill,
+[SYS_exec]      sys_exec,
+[SYS_fstat]     sys_fstat,
+[SYS_chdir]     sys_chdir,
+[SYS_dup]       sys_dup,
+[SYS_getpid]    sys_getpid,
+[SYS_sbrk]      sys_sbrk,
+[SYS_sleep]     sys_sleep,
+[SYS_uptime]    sys_uptime,
+[SYS_open]      sys_open,
+[SYS_write]     sys_write,
+[SYS_mknod]     sys_mknod,
+[SYS_unlink]    sys_unlink,
+[SYS_link]      sys_link,
+[SYS_mkdir]     sys_mkdir,
+[SYS_close]     sys_close,
+[SYS_trace]     sys_trace,
+[SYS_sysinfo]   sys_sysinfo,
+//[SYS_sigalarm]  sys_sigalarm,
+//[SYS_sigreturn] sys_sigreturn,
+//[SYS_symlink]   sys_symlink,
+//[SYS_mmap]      sys_mmap,
+//[SYS_munmap]    sys_munmap,
+//[SYS_connect]   sys_connect,
+[SYS_pgaccess]  sys_pgaccess,
 };
 
+char *syscall_names[] = {
+[SYS_fork]      "fork",
+[SYS_exit]      "exit",
+[SYS_wait]      "wait",
+[SYS_pipe]      "pipe",
+[SYS_read]      "read",
+[SYS_kill]      "kill",
+[SYS_exec]      "exec",
+[SYS_fstat]     "fstat",
+[SYS_chdir]     "chdir",
+[SYS_dup]       "dup",
+[SYS_getpid]    "getpid",
+[SYS_sbrk]      "sbrk",
+[SYS_sleep]     "sleep",
+[SYS_uptime]    "uptime",
+[SYS_open]      "open",
+[SYS_write]     "write",
+[SYS_mknod]     "mknod",
+[SYS_unlink]    "unlink",
+[SYS_link]      "link",
+[SYS_mkdir]     "mkdir",
+[SYS_close]     "close",
+[SYS_trace]     "trace",
+[SYS_sysinfo]   "sysinfo",
+//[SYS_sigalarm]  "sigalarm",
+//[SYS_sigreturn] "sigreturn",
+//[SYS_symlink]   "symlink",
+//[SYS_mmap]      "mmap",
+//[SYS_munmap]    "munmap",
+//[SYS_connect]   "connect",
+[SYS_pgaccess]  "pgaccess",
+};
 
+uint syscall_arg_counts[] = {
+[SYS_fork]      0,
+[SYS_exit]      1,
+[SYS_wait]      1,
+[SYS_pipe]      1,
+[SYS_read]      3,
+[SYS_kill]      1,
+[SYS_exec]      2,
+[SYS_fstat]     2,
+[SYS_chdir]     1,
+[SYS_dup]       1,
+[SYS_getpid]    0,
+[SYS_sbrk]      1,
+[SYS_sleep]     1,
+[SYS_uptime]    0,
+[SYS_open]      2,
+[SYS_write]     3,
+[SYS_mknod]     1,
+[SYS_unlink]    2,
+[SYS_link]      1,
+[SYS_mkdir]     1,
+[SYS_close]     1,
+[SYS_trace]     1,
+[SYS_sysinfo]   0,
+//[SYS_sigalarm]  0,
+//[SYS_sigreturn] 0,
+//[SYS_symlink]   0,
+//[SYS_mmap]      0,
+//[SYS_munmap]    0,
+//[SYS_connect]   0,
+[SYS_pgaccess]  3,
+};
 
 void
 syscall(void)
@@ -150,8 +220,27 @@ syscall(void)
   struct proc *p = myproc();
 
   num = p->trapframe->a7;
+  uint argc = syscall_arg_counts[num];
   if(num > 0 && num < NELEM(syscalls) && syscalls[num]) {
+    uint64 a0 = p->trapframe->a0;
     p->trapframe->a0 = syscalls[num]();
+
+    // implement tracing
+    if((1 << num) & p->tmsk && syscall_names[num]
+                            && syscall_arg_counts[num]) {
+      printf("%d: syscall %s (", p->pid, syscall_names[num]);
+
+      // print arguments
+      if(argc > 0) printf("%d", a0);
+      if(argc > 1) printf(", %d", p->trapframe->a1);
+      if(argc > 2) printf(", %d", p->trapframe->a2);
+      if(argc > 3) printf(", %d", p->trapframe->a3);
+      if(argc > 4) printf(", %d", p->trapframe->a4);
+      if(argc > 5) printf(", %d", p->trapframe->a5);
+
+      printf(") -> %d\n", p->trapframe->a0);
+    }
+
   } else {
     printf("%d %s: unknown sys call %d\n",
             p->pid, p->name, num);
diff --git a/kernel/syscall.h b/kernel/syscall.h
index 8da572e..120f04e 100644
--- a/kernel/syscall.h
+++ b/kernel/syscall.h
@@ -1,3 +1,6 @@
+#ifndef _SYS_SYSCALL_H
+#define _SYS_SYSCALL_H 1
+
 // System call numbers
 #define SYS_fork    1
 #define SYS_exit    2
@@ -31,3 +34,5 @@
 #define SYS_munmap    28
 #define SYS_connect   29
 #define SYS_pgaccess  30
+
+#endif
diff --git a/kernel/sysinfo.h b/kernel/sysinfo.h
new file mode 100644
index 0000000..0fb6c8f
--- /dev/null
+++ b/kernel/sysinfo.h
@@ -0,0 +1,9 @@
+#ifndef _SYS_SYSINFO_H
+#define _SYS_SYSINFO_H 1
+
+struct sysinfo {
+  uint64 freemem;   // amount of free memory (bytes)
+  uint64 nproc;     // number of processes
+};
+
+#endif
diff --git a/kernel/sysproc.c b/kernel/sysproc.c
index 3bd0007..1201995 100644
--- a/kernel/sysproc.c
+++ b/kernel/sysproc.c
@@ -75,16 +75,6 @@ sys_sleep(void)
   return 0;
 }
 
-
-#ifdef LAB_PGTBL
-int
-sys_pgaccess(void)
-{
-  // lab pgtbl: your code here.
-  return 0;
-}
-#endif
-
 uint64
 sys_kill(void)
 {
@@ -107,3 +97,39 @@ sys_uptime(void)
   release(&tickslock);
   return xticks;
 }
+
+uint64
+sys_trace(void)
+{
+  int n;
+
+  if(argint(0, &n) < 0)
+    return -1;
+  return trace(n);
+}
+
+uint64
+sys_sysinfo(void)
+{
+  uint64 p;
+
+  if(argaddr(0, &p) < 0)
+    return -1;
+  return sysinfo(p);
+}
+
+//#ifdef LAB_PGTBL
+uint64
+sys_pgaccess(void)
+{
+  uint64 va;
+  int n;
+  uint64 buf;
+
+  if(argaddr(0, &va) < 0 || argint(1, &n) < 0 || argaddr(2, &buf))
+    return -1;
+  return pgaccess(va, n, buf);
+  return 0;
+}
+//#endif
+
diff --git a/kernel/vm.c b/kernel/vm.c
index d5a12a0..8835889 100644
--- a/kernel/vm.c
+++ b/kernel/vm.c
@@ -432,3 +432,28 @@ copyinstr(pagetable_t pagetable, char *dst, uint64 srcva, uint64 max)
     return -1;
   }
 }
+
+void
+vmprint_recurse(pagetable_t pagetable, uint depth)
+{
+  for(int i = 0; i < PGTBL_ENTRIES; i++) {
+    pte_t pte = pagetable[i];
+    if((pte & PTE_V) && (pte & (PTE_R|PTE_W|PTE_X)) == 0) { // pagetable
+      // this points to a lower level page table
+      uint64 child = PTE2PA(pte);
+      for(int j = 0; j < depth; j++) printf(" ..");
+      printf("%d: pte %p pa %p\n", i, pte, child);
+      vmprint_recurse((pagetable_t)child, depth + 1);
+    } else if(pte & PTE_V) {                            // not pagetable
+      for(int j = 0; j < depth; j++) printf(" ..");
+      printf("%d: pte %p pa %p\n", i, pte, PTE2PA(pte));
+    }
+  }
+}
+
+void
+vmprint(pagetable_t pagetable)
+{
+  printf("page table %p\n", pagetable);
+  vmprint_recurse(pagetable, 1);
+}
diff --git a/user/pgtbltest.c b/user/pgtbltest.c
index bce158a..a6a5381 100644
--- a/user/pgtbltest.c
+++ b/user/pgtbltest.c
@@ -41,8 +41,13 @@ ugetpid_test()
         exit(1);
       continue;
     }
-    if (getpid() != ugetpid())
+    int p1 = getpid();
+    int p2 = ugetpid();
+    printf("== getpid(): %d, ugetpid(): %d\n", p1, p2);
+
+    if (p1 != p2){
       err("missmatched PID");
+    }
     exit(0);
   }
   printf("ugetpid_test: OK\n");
diff --git a/user/sh.c b/user/sh.c
index 83dd513..c96dab0 100644
--- a/user/sh.c
+++ b/user/sh.c
@@ -54,6 +54,7 @@ void panic(char*);
 struct cmd *parsecmd(char*);
 
 // Execute cmd.  Never returns.
+__attribute__((noreturn))
 void
 runcmd(struct cmd *cmd)
 {
diff --git a/user/sysinfotest.c b/user/sysinfotest.c
new file mode 100644
index 0000000..254f6d2
--- /dev/null
+++ b/user/sysinfotest.c
@@ -0,0 +1,132 @@
+#include "kernel/types.h"
+#include "kernel/riscv.h"
+#include "kernel/sysinfo.h"
+#include "user/user.h"
+
+
+void
+sinfo(struct sysinfo *info) {
+  if (sysinfo(info) < 0) {
+    printf("FAIL: sysinfo failed");
+    exit(1);
+  }
+}
+
+//
+// use sbrk() to count how many free physical memory pages there are.
+//
+int
+countfree()
+{
+  uint64 sz0 = (uint64)sbrk(0);
+  struct sysinfo info;
+  int n = 0;
+
+  while(1){
+    if((uint64)sbrk(PGSIZE) == 0xffffffffffffffff){
+      break;
+    }
+    n += PGSIZE;
+  }
+  sinfo(&info);
+  if (info.freemem != 0) {
+    printf("FAIL: there is no free mem, but sysinfo.freemem=%d\n",
+      info.freemem);
+    exit(1);
+  }
+  sbrk(-((uint64)sbrk(0) - sz0));
+  return n;
+}
+
+void
+testmem() {
+  struct sysinfo info;
+  uint64 n = countfree();
+  
+  sinfo(&info);
+
+  if (info.freemem!= n) {
+    printf("FAIL: free mem %d (bytes) instead of %d\n", info.freemem, n);
+    exit(1);
+  }
+  
+  if((uint64)sbrk(PGSIZE) == 0xffffffffffffffff){
+    printf("sbrk failed");
+    exit(1);
+  }
+
+  sinfo(&info);
+    
+  if (info.freemem != n-PGSIZE) {
+    printf("FAIL: free mem %d (bytes) instead of %d\n", n-PGSIZE, info.freemem);
+    exit(1);
+  }
+  
+  if((uint64)sbrk(-PGSIZE) == 0xffffffffffffffff){
+    printf("sbrk failed");
+    exit(1);
+  }
+
+  sinfo(&info);
+    
+  if (info.freemem != n) {
+    printf("FAIL: free mem %d (bytes) instead of %d\n", n, info.freemem);
+    exit(1);
+  }
+}
+
+void
+testcall() {
+  struct sysinfo info;
+  
+  if (sysinfo(&info) < 0) {
+    printf("FAIL: sysinfo failed\n");
+    exit(1);
+  }
+
+  if (sysinfo((struct sysinfo *) 0xeaeb0b5b00002f5e) !=  0xffffffffffffffff) {
+    printf("FAIL: sysinfo succeeded with bad argument\n");
+    exit(1);
+  }
+}
+
+void testproc() {
+  struct sysinfo info;
+  uint64 nproc;
+  int status;
+  int pid;
+  
+  sinfo(&info);
+  nproc = info.nproc;
+
+  pid = fork();
+  if(pid < 0){
+    printf("sysinfotest: fork failed\n");
+    exit(1);
+  }
+  if(pid == 0){
+    sinfo(&info);
+    if(info.nproc != nproc+1) {
+      printf("sysinfotest: FAIL nproc is %d instead of %d\n", info.nproc, nproc+1);
+      exit(1);
+    }
+    exit(0);
+  }
+  wait(&status);
+  sinfo(&info);
+  if(info.nproc != nproc) {
+      printf("sysinfotest: FAIL nproc is %d instead of %d\n", info.nproc, nproc);
+      exit(1);
+  }
+}
+
+int
+main(int argc, char *argv[])
+{
+  printf("sysinfotest: start\n");
+  testcall();
+  testmem();
+  testproc();
+  printf("sysinfotest: OK\n");
+  exit(0);
+}
diff --git a/user/trace.c b/user/trace.c
new file mode 100644
index 0000000..dd77760
--- /dev/null
+++ b/user/trace.c
@@ -0,0 +1,27 @@
+#include "kernel/param.h"
+#include "kernel/types.h"
+#include "kernel/stat.h"
+#include "user/user.h"
+
+int
+main(int argc, char *argv[])
+{
+  int i;
+  char *nargv[MAXARG];
+
+  if(argc < 3 || (argv[1][0] < '0' || argv[1][0] > '9')){
+    fprintf(2, "Usage: %s mask command\n", argv[0]);
+    exit(1);
+  }
+
+  if (trace(atoi(argv[1])) < 0) {
+    fprintf(2, "%s: trace failed\n", argv[0]);
+    exit(1);
+  }
+  
+  for(i = 2; i < argc && i < MAXARG; i++){
+    nargv[i-2] = argv[i];
+  }
+  exec(nargv[0], nargv);
+  exit(0);
+}
diff --git a/user/user.h b/user/user.h
index 8aed44e..bcc3655 100644
--- a/user/user.h
+++ b/user/user.h
@@ -24,6 +24,9 @@ int getpid(void);
 char* sbrk(int);
 int sleep(int);
 int uptime(void);
+int trace(int);
+int sysinfo(struct sysinfo *);
+
 #ifdef LAB_NET
 int connect(uint32, uint16, uint16);
 #endif
diff --git a/user/usys.pl b/user/usys.pl
index 6453fe9..f084c63 100755
--- a/user/usys.pl
+++ b/user/usys.pl
@@ -36,5 +36,7 @@ entry("getpid");
 entry("sbrk");
 entry("sleep");
 entry("uptime");
+entry("trace");
+entry("sysinfo");
 entry("connect");
 entry("pgaccess");
